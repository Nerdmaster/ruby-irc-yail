High priority
=============

* Allow user to specify IO object for connection so TCPSocket can be overridden.  Write unit tests
  after doing so, using mocked socket object.
* Get event handling/filtering methods into a module to include - slightly cleaner I think
* New dispatch routine to deal with new event system:
  * Create dispatch() method.  For 1.5, this calls handle() after callbacks but before after-
    callback filters.  Later, handle() just disappears, along with prepend_handler, etc.
  * Dispatch is called on parent event.
  * Code:
        def dispatch(event)
          if (event.child.nil? || propagation.include?(event.type))
            call_before_filters(event)
            callback(event)
            legacy_handle(event)  # this will house the legacy logic currently living in process_input
            call_after_filters(event)
            return
          end
          dispatch(event.child);
        end
* Figure out best approach for handling :incoming_any - custom event object probably, filters
  only - no callback since you can't "handle" unknown data.  Callbacks are for doing a specific task
  once you have data.

* Make events more like a plugin kind of system.
  X Each event can have pre-callback and post-callback filters.
    X These would include internal things like the handling of changing bot's nick.
    X User could add his own.
    X All after-filters always run - no breaking the chain!
  X User normally registers a single callback - this is the definitive handler for a given IRC event.
    X New method, set_callback or similar.  Basically overwrites callback for a given event.
    X Deprecate prepend_handler code - give warning to $stderr, even.
  * Callbacks should be used for things like a bot that does a certain action when his name is
    spoken in a channel, for instance - an actual handling of the event.
  * Filters should be used for back-end tasks, like logging, modifying text, storing stats, etc.
  * Outgoing events need to be separate in some way because while they can be filtered, the default
    handling has to remain for them to work!
    * Make a better OutgoingEvent system - they aren't events, they're commands, and they can't be
      "handled".  We can have filters before they're sent, but technically the callback is internal
      and should not be bypassed.
      * Create a new object for all commands in the output api - output function creates object
        with raw data, but our internal callback spits out raw data to socket.  User can
        filter or even cancel the event from happening, but shouldn't set up a callback easily - it
        will hopefully be hard enough that the average person doesn't bother.
  * Redo logger and dumbbot when this is ready
  * Get all docs up to date:
    * README.md
    * yail.rb comments
      * Most class-level comments have to be thrown out and rewritten from scratch :(
    * YAIL-RDOC
      * Maybe get rid of this and just have "main" page in rdoc be yail.rb?
  * Build example plugin or two so this functionality isn't meaningless!  Speech filtering, ignore
    (by hostmask regex or nick or whatever), command-callback system (register commands, user enters
    "!command" and command-callback hits) come to mind.
  * Consider allowing a default of :incoming_xxx on callback, since those are only allowed for
    incoming events, and even filters so only outgoing filters require explicit :outgoing_xxx
    * Re-consider functional semantics like "before_say_xxx ..." for :outgoing_xxx filter, etc. -
      less work for user than "add_before_filter(:outgoing_xxx ..."
      * Filters: sending_xxx, sent_xxx, hearing_xxx, heard_xxx - not perfect, but somewhat intuitive
      * Callback is easy: on_xxx - THERE CAN BE ONLY ONE, and only for incoming events!
      * Handling custom events would be manual:
        * before_filter(:some_event_type, code)
        * set_callback(:some_event_type) {|event| do_stuff(event);}
        * after_filter(:some_event_type, code)

Version 1.5
===========

API changes:
------------

Deprecating prepend_handler in favor of before_filter, set_callback, and after_filter.
prepend_handler and current event system stay in for a while, but won't last forever....

Related to above: callback and filters must very explicitly break the chain, and it should
only be done in very specific situations.

Callbacks should be looked at as the core code, the response to an action.  They
should be used to actually handle an event: a bot's "PRIVMSG #channel Hey there, bob" output on
a "bob joins the channel" message.  Filters are more for behind-the-scenes stuff: responding to a
PING, storing stats, logging, manipulating input/output, changing variables (bot's nickname on an
:incoming_nick event), etc.

A plugin could use a filter where one isn't really appropriate, and this may make sense for a
plugin built for a very specific purpose - but the *final* program should be the only thing that
registers the callback, because there can be only one.  When you call set_callback, any previous
callback is lost, PERIOD.

Looking at this like Rails, the callback would be the action, while filters would be... filters.
Looking at it like wordpress, the callback is the core WP code, while the filters are your plugin
actions.  One plugin author shouldn't be breaking another's ability to work.  Again, exceptions to
every rule: for instance, an "ignore user" plugin could stop an event from ever reaching the
callback.


Version 2.0
===========

When ready to change the API in a major way

* Fix events to give more useful output for :incoming_mode events - at the least, parse out the
  various targets as some kind of hash.  Very complex mode-parsing may be necessary.
  This is one place where API consistency (using .text and such) is less important than usability.
  * Example: For the command ":User!foo@bar.com MODE #bots +bivk-mv Towelie!*@* Doogles foo Towelie"
    * User is banning Towelie!*@*
    * User is setting "+i" to #bots
    * User is giving Doogles +v
    * User is setting channel key to "foo"
    * User is setting "-m" on #bots
    * User is taking away Towelie's voice (-v)
* Offer a way to let user specify when setting a callback that should be run for all children
  of a given event.
  * That setting should raise an exception if any callback has already been set for a child of the
    event.
  * When setting a callback, an exception should be raised if a parent of the callback has already
    been set up to handle all child events.
  * Filters should always run for all child events, since they are meant to run without obstruction
    and regardless of final callback.
    * An ignore filter would be far more useful if it could just trap messages at the privmsg level,
      for instance, rather than capturing message, action, ctcp, and so forth.  In that case, ignore
      filter stops all further filtering and any callback that would have run.
    * A stats gathering filter may be similar in that it only cares about the privmsg level, but it
      doesn't want to stop any act-level filtering that may be set up.
    * However, we don't *ever* want the same filter to run for an event multiple times!  If we have
      set a function to catch privmsg and do something, we don't want to hit it for the parent event
      (privmsg), then again for the ctcp event (child of privmsg) and then *again* for the act
      event (child of ctcp).
* Allow user to specify some way to decide when to call parent event callback
  * Use cases:
    * User may register :incoming_msg callback and doesn't want to handle ctcp and action
      * (today's YAIL acts this way - all events must be explicitly handled)
    * User registers :incoming_ctcp and forever wants all children of that type to propagate up
      * (today's YAIL has no way to do this)
  * User registers events whose children always propagate up.
    * Event parser builds events in a double-linked-list structure so it can register only the
      parent, and we can travel *down* from there.
* Remove prepend_handler completely, remove all legacy code supporting it.
* Kill old log @loud and @silent stuff
* Remove filtering code from YAIL's initialize() - move to plugin user must explicitly include
* Pull out nickname-in-use handler and make that only part of IRCBot, not YAIL
* Simply store nicknames in default namreply handler - that is, kill all report() calls
* Remove report() calls in magic events

Low priority
============

Someday....

* Allow multiple targets / hostmask / etc in outgoing PRIVMSG and NOTICE
* Allow incoming PRIVMSG to have multiple parts - :actor PRIVMSG victim :Hello there, sir!\001USERINFO\001
  * Allow IncomingEvent.parse to actually return multiple events?  Would help with modes, too.
  * Add special callbacks for some of this stuff so it's not up to user to parse.
    :incoming_userinfo, :incoming_version, :outgoing_userinfo, etc.
* Allow for CTCP quoting/dequoting...?  Don't know much about this - read up!
* CTCP formatting:
  * Color is ^C<fore>[,<back>]
  * Bold is ^B to toggle on or off
  * See silverplatter - appears to have all formatting options I'd want.
    Yay theft!
  * Use *optional* output filtering to allow pipe-commands, such as
    "|2,3|BFoo|PBar" => bolded blue on green "Foo", followed by plain "Bar"
* CTCP commands (VERSION, PING, etc): http://www.invlogic.com/irc/ctcp.html
* Figure a nice way to do better throttling for output.  If there are enough
  channels or people bugging a bot, it could spam itself off the network right
  now due to the "send one message per second... to every damn thing that has
  something in its queue" rule.
